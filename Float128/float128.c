#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Количество цифр в разных числах:
// 2^32			10
// 2^64			20
// 2^128		39
// 2^256		78
// 2^512		155
// 2^1024		309
// 2^2048		617
// 2^4096		1234
//
// Такими будут затраты памяти на представление в ASCII
//

//
// При превышении отметки в 16777216, т.е. 2^24, Float32 испытает деградацию в точности
// Представлять нечётные числа станет невозможно из-за потери самого младшего бита
// Дальнейшая деградация произойдёт при превышении отметки в 2^25
//
// Если число меньше 2^24, то оно сдвигается влево до встречи выставленного бита
// Возникшее пространство представляет дробную часть
//
// Если число больше 2^24, то оно сдвигается вправо, теряя точность
// Дробная часть отсутствует
//

//
// Значение положительной экспоненты, т.е. 0x80 + n, напрямую устанавливает отступ
//

//
// Числа от 0 до 1: альтернативный режим, мантисса 24 бита
//

float load_float32(int number) {
	int temp = 0;
	int sign = 0;

	// Сохранить знак
	if (number < 0) {
		number = -number;
		sign = 1;
	}

	// 1	Знак
	// 8	Экспонента
	// 23	Мантисса
	#define SIGN_MASK		0b10000000000000000000000000000000
	#define EXPONENT_MASK	0b01111111100000000000000000000000
	#define MANTISSA_MASK	0b00000000011111111111111111111111

	// Вставить мантиссу и выполнить нормализацию
	temp = number;

	// Ведущие нули
	int lz = 0;

	while (!(temp & EXPONENT_MASK)) {
		temp = temp << 1;
		lz++;
	}

	// Если число равно 2 или 1, то lo_exp станет отрицательным
	int lo_exp = 21 - lz;

	// Экспонента:
	// 0x00		-127
	// 0xFE		 127
	// 0xFF		 Infinity
	//
	// Загрузить положительную экспоненту
	temp += (0x80 | lo_exp) << 23;

	return *(float*)&temp;
}

int main() {
	printf("Load float: %f\n", load_float32(16777216+3));
}
